#!/usr/bin/env bash
# Pre-commit hook: prevent accidental commit of private data to the public dagnet repo.
#
# Reads private repo directory names from .private-repos.conf.
#
# Setup (one-time per clone):
#   git config core.hooksPath .githooks
#
# Bypass (only if you know what you're doing):
#   git commit --no-verify

set -euo pipefail

REPO_ROOT="$(git rev-parse --show-toplevel)"
CONF="$REPO_ROOT/.private-repos.conf"

# ─── Load repo directory names from config ────────────────────────────────────

DATA_REPO_DIR=""
MONOREPO_DIR=""

if [ ! -f "$CONF" ]; then
  echo ""
  echo "╔══════════════════════════════════════════════════════════════════╗"
  echo "║  BLOCKED: Missing private repo config                          ║"
  echo "╚══════════════════════════════════════════════════════════════════╝"
  echo ""
  echo "Expected config file: $CONF"
  echo "This repo uses it to block accidental commits of private repos."
  echo ""
  echo "Fix: create/edit .private-repos.conf then run: bash scripts/setup-workspace.sh"
  echo ""
  exit 1
fi

# Read only the two expected variables (safe: no eval of arbitrary code)
DATA_REPO_DIR=$(grep '^DATA_REPO_DIR=' "$CONF" | cut -d= -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
MONOREPO_DIR=$(grep '^MONOREPO_DIR=' "$CONF" | cut -d= -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

if [ -z "$DATA_REPO_DIR" ] || [ -z "$MONOREPO_DIR" ]; then
  echo ""
  echo "╔══════════════════════════════════════════════════════════════════╗"
  echo "║  BLOCKED: Invalid private repo config                          ║"
  echo "╚══════════════════════════════════════════════════════════════════╝"
  echo ""
  echo "Both DATA_REPO_DIR and MONOREPO_DIR must be set in:"
  echo "  $CONF"
  echo ""
  exit 1
fi

escape_ere() {
  # Escape an arbitrary string for use in grep -E.
  # shellcheck disable=SC2001
  echo "$1" | sed 's/[][(){}.^$|*+?\\/]/\\&/g'
}

# Build grep pattern from configured names
PRIVATE_DIRS=""
DATA_REPO_DIR_ERE="$(escape_ere "$DATA_REPO_DIR")"
MONOREPO_DIR_ERE="$(escape_ere "$MONOREPO_DIR")"
PRIVATE_DIRS="^${DATA_REPO_DIR_ERE}/|^${MONOREPO_DIR_ERE}/"

ERRORS=0

# ─── Check 1: No private repo files staged ───────────────────────────────────

if [ -n "$PRIVATE_DIRS" ]; then
  COMMERCIAL_FILES=$(git diff --cached --name-only | grep -E "$PRIVATE_DIRS" || true)
  if [ -n "$COMMERCIAL_FILES" ]; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  BLOCKED: Private repo files staged for commit                 ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "The following private files are staged:"
    echo "$COMMERCIAL_FILES" | while read -r f; do echo "  - $f"; done
    echo ""
    echo "Private repos must NEVER be committed to the public dagnet repository."
    echo ""
    echo "To unstage: git reset HEAD <path>"
    echo ""
    ERRORS=$((ERRORS + 1))
  fi
fi

# ─── Check 2: No sensitive data patterns in staged diffs ─────────────────────
#
# We scan the actual diff content (not full files) so we only catch NEW additions.
# Exclude paths that legitimately document these patterns.

DIFF_TO_SCAN=$(git diff --cached --unified=0 \
  -- . \
  ':!graph-editor/public/param-schemas/' \
  ':!.githooks/' \
  2>/dev/null || true)

if [ -n "$DIFF_TO_SCAN" ]; then

  # Pattern: cumulativeRaw (Amplitude response field containing real user counts)
  # Match JSON-style '"cumulativeRaw"' to avoid false positives in docs.
  CUMRAW_HITS=$(echo "$DIFF_TO_SCAN" | grep -n '^\+.*"cumulativeRaw"' || true)
  if [ -n "$CUMRAW_HITS" ]; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  WARNING: Amplitude cumulativeRaw data detected in staged diff ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "Lines containing real Amplitude user counts:"
    echo "$CUMRAW_HITS" | head -5
    echo ""
    echo "cumulativeRaw contains real user conversion counts from Amplitude."
    echo "This data should NOT be committed to the public repo."
    echo ""
    ERRORS=$((ERRORS + 1))
  fi

  # Pattern: Known API key strings (catch re-introduction of revoked credentials)
  LEAKED_KEYS=$(echo "$DIFF_TO_SCAN" | grep -n '^\+.*\(AMPLITUDE_API_KEY_REDACTED\|AMPLITUDE_SECRET_KEY_REDACTED\)' || true)
  if [ -n "$LEAKED_KEYS" ]; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  BLOCKED: Known API credentials in staged diff                 ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "Detected known (revoked) API key or secret."
    echo "Use .env.amplitude.local for credentials — see local-env/amplitude.env.example"
    echo ""
    ERRORS=$((ERRORS + 1))
  fi

  # Pattern: Generic API key/secret hardcoded in scripts (heuristic)
  # Matches: API_KEY="<32+ hex chars>" or SECRET_KEY="<32+ hex chars>"
  HARDCODED_KEYS=$(echo "$DIFF_TO_SCAN" | grep -nE '^\+.*(API_KEY|SECRET_KEY)\s*=\s*"[0-9a-fA-F]{32,}"' || true)
  if [ -n "$HARDCODED_KEYS" ]; then
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════╗"
    echo "║  WARNING: Possible hardcoded API credentials in staged diff    ║"
    echo "╚══════════════════════════════════════════════════════════════════╝"
    echo ""
    echo "$HARDCODED_KEYS" | head -5
    echo ""
    echo "API keys should be loaded from .env files, not hardcoded."
    echo "See local-env/amplitude.env.example"
    echo ""
    ERRORS=$((ERRORS + 1))
  fi

fi

# ─── Result ───────────────────────────────────────────────────────────────────

if [ "$ERRORS" -gt 0 ]; then
  echo "Pre-commit check FAILED ($ERRORS issue(s)). Commit aborted."
  echo "To bypass (use with caution): git commit --no-verify"
  exit 1
fi

exit 0

{
  "$id": "https://raw.githubusercontent.com/gjbm2/dagnet/main/schema/conversion-graph-1.1.0.json",
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Conversion Funnel Graph",
  "$comment": "Graph JSON for a conversion funnel DAG. Key semantics: (1) At least one node must have entry.is_start=true; (2) Terminal nodes must have absorbing=true and zero outgoing edges; (3) Outgoing edge probabilities from non-absorbing nodes should sum to 1.0 or use residual_behavior/policies; (4) Case nodes (type='case') split traffic across variants - each variant needs a corresponding case edge with case_id matching case.id (preferred) or node.uuid (fallback), and case_variant matching the variant name; (5) Case edges use p.mean=1.0 because split is controlled by variant weights.",
  "type": "object",
  "required": ["nodes", "edges", "policies", "metadata"],
  "additionalProperties": false,
  "properties": {
    "nodes": {
      "type": "array",
      "minItems": 1,
      "items": { "$ref": "#/$defs/Node" }
    },
    "edges": {
      "type": "array",
      "minItems": 0,
      "items": { "$ref": "#/$defs/Edge" }
    },
    "policies": { "$ref": "#/$defs/Policies" },
    "metadata": { "$ref": "#/$defs/Metadata" },
    "currentQueryDSL": {
      "type": "string",
      "description": "Current user query DSL for UI persistence (e.g., window(1-Jan-25:31-Mar-25)). Optional."
    },
    "dataInterestsDSL": {
      "type": "string",
      "description": "Pinned DSL for batch/overnight fetches. Determines which slices are pre-materialised in param files. Example: or(cohort(-90d:), window(-14d:)).context(channel)"
    },
    "baseDSL": {
      "type": "string",
      "description": "Base DSL used for live scenario inheritance (persistent). Composed with scenario meta.queryDSL via smart merge."
    },
    "debugging": {
      "type": "boolean",
      "default": false,
      "description": "Optional. If true, the editor will automatically run Graph Issues checks while this graph is open and display an Issues indicator overlay."
    },
    "dailyFetch": {
      "type": "boolean",
      "default": false,
      "description": "If true, this graph is included in unattended daily automation runs when ?retrieveall is used without an explicit graph list."
    }
  },
  "$defs": {
    "UUID": { "type": "string", "format": "uuid" },
    "Id": { 
      "type": "string", 
      "minLength": 0, 
      "maxLength": 128,
      "pattern": "^[a-zA-Z0-9_-]*$",
      "$comment": "Empty IDs are permitted but discouraged. Assign meaningful kebab-case identifiers for clarity.",
      "description": "Human-readable identifier (letters, numbers, hyphens, underscores). Empty is allowed but discouraged."
    },

    "Node": {
      "type": "object",
      "required": ["uuid"],
      "additionalProperties": false,
      "properties": {
        "uuid": { "$ref": "#/$defs/UUID" },
        "id": { "$ref": "#/$defs/Id" },
        "type": {
          "type": "string",
          "enum": ["normal", "case"],
          "default": "normal",
          "description": "Node type. Use 'case' for A/B test nodes that split traffic across experiment variants. Case nodes MUST also have a 'case' property defining variants."
        },
        "label": { "type": "string", "maxLength": 256 },
        "label_overridden": { "type": "boolean", "default": false, "description": "If true, label was manually edited and should not be auto-updated" },
        "description": { "type": "string" },
        "description_overridden": { "type": "boolean", "default": false, "description": "If true, description was manually edited and should not be auto-updated" },
        "event_id": {
          "type": "string",
          "pattern": "^[a-zA-Z0-9_-]+$",
          "description": "Direct event ID for DAS queries (letters, numbers, hyphens, underscores)"
        },
        "event_id_overridden": { "type": "boolean", "default": false, "description": "If true, event_id was manually edited and should not be auto-updated" },
        "event": {
          "type": "object",
          "description": "Event reference for this node (optional)",
          "additionalProperties": false,
          "properties": {
            "id": { "type": "string", "pattern": "^[a-zA-Z0-9_-]+$", "description": "Reference to event in events registry (letters, numbers, hyphens, underscores)" },
            "id_overridden": { "type": "boolean", "default": false, "description": "If true, event ID was manually edited and should not be auto-updated" }
          },
          "required": ["id"]
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "uniqueItems": true
        },
        "absorbing": { 
          "type": "boolean", 
          "default": false,
          "description": "Terminal node flag. If true, this node ends a path and MUST have zero outgoing edges. Typically used for success/failure/abandon outcomes. Should be paired with outcome_type."
        },
        "outcome_type": {
          "type": "string",
          "enum": ["success", "failure", "error", "neutral", "other"],
          "description": "Classification for absorbing outcomes (success, failure, etc.). Optional but recommended for terminal nodes."
        },
        "outcome_type_overridden": { "type": "boolean", "default": false, "description": "If true, outcome_type was manually edited and should not be auto-updated" },
        "entry": {
          "type": "object",
          "description": "Entry point configuration. At least one node in the graph MUST have is_start=true to define where traffic enters.",
          "additionalProperties": false,
          "properties": {
            "is_start": { 
              "type": "boolean", 
              "default": false,
              "description": "If true, this node is a traffic entry point. At least one node must have is_start=true."
            },
            "entry_weight": { 
              "type": "number", 
              "minimum": 0,
              "description": "Relative weight for multi-entry graphs. If multiple nodes have is_start=true, traffic is split proportionally by entry_weight."
            }
          }
        },
        "costs": { 
          "$ref": "#/$defs/Costs",
          "$comment": "DEPRECATED: Node costs are no longer used. Costs are only tracked on edges (cost_gbp and labour_cost). Runner calculates per-node costs by accumulating edge costs along paths.",
          "deprecated": true
        },
        "residual_behavior": { "$ref": "#/$defs/ResidualBehavior" },
        "case": {
          "type": "object",
          "description": "A/B test or experiment configuration. Required when type='case'. The case node routes 100% of incoming traffic across its variants according to variant weights. Each variant MUST have a corresponding outgoing edge with case_variant matching the variant name and case_id referencing this case.",
          "additionalProperties": false,
          "properties": {
            "uuid": { "$ref": "#/$defs/UUID" },
            "id": { 
              "type": "string",
              "maxLength": 128,
              "pattern": "^[a-zA-Z0-9_-]*$",
              "description": "Semantic identifier for this experiment (e.g., 'checkout-ab-test', 'cart-experiment-2025'). Strongly recommended - used by case edges and conditional_p references. If empty, system falls back to node.uuid."
            },
            "status": {
              "type": "string",
              "enum": ["active", "paused", "completed"],
              "default": "active"
            },
            "connection": { "type": "string", "description": "Connection name from connections.yaml" },
            "connection_string": { "type": "string", "description": "JSON blob of provider-specific settings" },
            "evidence": {
              "type": "object",
              "description": "Evidence from last variant fetch",
              "additionalProperties": false,
              "properties": {
                "source": { "type": "string", "description": "Connection name used for this fetch" },
                "fetched_at": { "type": "string", "description": "Timestamp of fetch (UK format or ISO)" },
                "path": { "type": "string", "enum": ["direct", "file"], "description": "How this data was retrieved: 'direct' = fetched directly from connection, 'file' = synced from case file" },
                "full_query": { "type": "string", "description": "Complete query string used for this fetch (case_id + environment + any filters). Example: case(checkout_test).env(production)" },
                "variants": {
                  "type": "array",
                  "description": "Fetched variant allocations",
                  "items": {
                    "type": "object",
                    "properties": {
                      "variant_id": { "type": "string" },
                      "name": { "type": "string" },
                      "allocation": { "type": "number" }
                    }
                  }
                },
                "debug_trace": { "type": "string", "description": "Complete execution trace as JSON string for debugging/provenance" }
              }
            },
            "variants": {
              "type": "array",
              "items": {
                "type": "object",
                "required": ["name", "weight"],
                "properties": {
                  "name": { "type": "string" },
                  "name_overridden": { "type": "boolean", "default": false, "description": "If true, name was manually edited and should not be auto-updated" },
                  "weight": { "type": "number", "minimum": 0, "maximum": 1 },
                  "weight_overridden": { "type": "boolean", "default": false, "description": "If true, weight was manually edited and should not be auto-updated" }
                }
              }
            }
          }
        },
        "layout": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "x": { "type": "number" },
            "y": { "type": "number" },
            "rank": { "type": "integer", "minimum": 0 },
            "group": { "type": "string", "maxLength": 128 },
            "colour": { "type": "string", "pattern": "^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$" }
          }
        },
        "url": {
          "type": "string",
          "format": "uri",
          "description": "External URL for this node (can override registry node)"
        },
        "url_overridden": {
          "type": "boolean",
          "default": false,
          "description": "If true, URL was manually edited and should not auto-sync from registry"
        },
        "images": {
          "type": "array",
          "description": "Images attached to this node (can override registry node)",
          "items": {
            "type": "object",
            "required": ["image_id", "caption"],
            "additionalProperties": false,
            "properties": {
              "image_id": { "type": "string", "pattern": "^[a-zA-Z0-9_-]+$" },
              "caption": { "type": "string", "maxLength": 256 },
              "caption_overridden": { 
                "type": "boolean", 
                "default": false,
                "description": "If true, caption was manually edited at graph level"
              },
              "file_extension": { 
                "type": "string", 
                "enum": ["png", "jpg", "jpeg"] 
              }
            }
          }
        },
        "images_overridden": {
          "type": "boolean",
          "default": false,
          "description": "If true, images array was manually modified and should not auto-sync from registry"
        }
      }
    },

    "Edge": {
      "type": "object",
      "required": ["uuid", "from", "to"],
      "additionalProperties": false,
      "$comment": "Case edges (from case nodes to variant destinations) have special semantics: (1) case_id should match the parent case node's case.id (preferred) or node.uuid (fallback if case.id is empty), (2) case_variant must match a variant name from case.variants, (3) p.mean should be 1.0 because traffic split is controlled by variant weights not edge probability, (4) there should be exactly one case edge per variant.",
      "properties": {
        "uuid": { "$ref": "#/$defs/UUID" },
        "id": { "$ref": "#/$defs/Id" },
        "from": { 
          "type": "string", 
          "minLength": 1, 
          "$comment": "Node uuid or id; runner canonicalizes to uuid and checks existence." 
        },
        "to": { 
          "type": "string", 
          "minLength": 1, 
          "$comment": "Node uuid or id; runner canonicalizes to uuid and checks existence." 
        },
        "fromHandle": {
          "type": "string",
          "enum": ["left", "right", "top", "bottom", "left-out", "right-out", "top-out", "bottom-out"],
          "description": "Handle on source node where edge originates"
        },
        "toHandle": {
          "type": "string", 
          "enum": ["left", "right", "top", "bottom", "left-out", "right-out", "top-out", "bottom-out"],
          "description": "Handle on target node where edge terminates"
        },
        "label": { "type": "string", "maxLength": 256, "description": "Edge label (auto-derived from upstream/downstream nodes unless overridden)" },
        "label_overridden": { "type": "boolean", "default": false, "description": "If true, label was manually edited and should not be auto-updated" },
        "description": { "type": "string" },
        "description_overridden": { "type": "boolean", "default": false, "description": "If true, description was manually edited and should not be auto-updated" },
        "query": { "type": "string", "pattern": "^from\\([a-z0-9_-]+\\)\\.to\\([a-z0-9_-]+\\)", "description": "Query expression for data retrieval (auto-generated by MSMDC or manual)" },
        "query_overridden": { "type": "boolean", "default": false, "description": "If true, query was manually edited and should not be auto-regenerated" },
        "n_query": { "type": "string", "description": "Optional explicit query for n (denominator) when it differs from k query. Used when 'from' node shares an event with siblings and n can't be derived by stripping upstream conditions. Result's k (to_count) is used as n for the main query." },
        "n_query_overridden": { "type": "boolean", "default": false, "description": "If true, n_query was manually edited and should not be auto-regenerated" },
        "p": { 
          "$ref": "#/$defs/ProbabilityParam",
          "description": "Transition probability P(to|from). For normal edges: probability of taking this path (outgoing edges from a node should sum to 1.0 or use residual_behavior). For case edges: should be 1.0 (traffic split controlled by variant weights)."
        },
        "conditional_p": {
          "type": "array",
          "items": { "$ref": "#/$defs/ConditionalProbability" },
          "description": "Optional array of conditional probabilities. Evaluated in order; first match wins. Falls back to p if no matches."
        },
        "weight_default": {
          "type": "number",
          "minimum": 0,
          "description": "Used to distribute residual among free edges from the same source; proportional with others."
        },
        "cost_gbp": { "$ref": "#/$defs/CostParam" },
        "labour_cost": { "$ref": "#/$defs/CostParam" },
        "case_variant": {
          "type": "string",
          "maxLength": 128,
          "description": "For case edges only: the variant name this edge represents. Must exactly match one of the variant names in the parent case node's case.variants array."
        },
        "case_id": {
          "type": "string",
          "description": "For case edges only: identifies the parent case node. Preferred: use Node.case.id (the semantic experiment identifier). Fallback: if case.id is empty, the system uses Node.uuid. When creating graphs manually, set this to match either the case node's case.id (preferred) or its uuid."
        },
        "display": { 
          "$ref": "#/$defs/EdgeDisplay",
          "description": "Display parameters for editor (colours, grouping)"
        }
      }
    },

    "ProbabilityParam": {
      "type": "object",
      "additionalProperties": false,
      "$comment": "p.mean is P(to|from). Primary value is what user sees/edits. Evidence (n/k) stored separately. Override flags use suffix pattern. If mean absent, edge is 'free' and filled by policy.",
      "properties": {
        "mean": { "type": "number", "minimum": 0, "maximum": 1, "description": "Probability value (primary, user-facing)" },
        "mean_overridden": { "type": "boolean", "default": false, "description": "If true, mean was manually edited and should not be auto-updated" },
        "stdev": { "type": "number", "minimum": 0, "description": "Standard deviation" },
        "stdev_overridden": { "type": "boolean", "default": false, "description": "If true, stdev was manually edited and should not be auto-updated" },
        "distribution": { 
          "type": "string", 
          "enum": ["normal", "beta", "uniform"],
          "default": "beta",
          "description": "Probability distribution type (beta recommended for probabilities)"
        },
        "distribution_overridden": { "type": "boolean", "default": false, "description": "If true, distribution was manually edited and should not be auto-updated" },
        "connection": { "type": "string", "description": "Connection name from connections.yaml" },
        "connection_overridden": { "type": "boolean", "default": false, "description": "If true, connection settings were manually edited and should not be auto-synced" },
        "connection_string": { "type": "string", "description": "JSON blob of provider-specific settings" },
        "evidence": {
          "type": "object",
          "description": "Observations from data sources (context for n/k, NOT overridable). Optional fields depend on source type.",
          "additionalProperties": false,
          "properties": {
            "n": { "type": "integer", "minimum": 0, "description": "Sample size (total trials) - required for probability data with observations" },
            "k": { "type": "integer", "minimum": 0, "description": "Number of successes - optional, can be derived from n × mean" },
            "mean": { "type": "number", "minimum": 0, "maximum": 1, "description": "Evidence probability: raw observed rate = k/n (query-time computed scalar)" },
            "stdev": { "type": "number", "minimum": 0, "description": "Evidence uncertainty: binomial stdev for the evidence rate (query-time computed scalar)" },
            "window_from": { "type": "string", "description": "Time window start (UK format d-MMM-yy or ISO)" },
            "window_to": { "type": "string", "description": "Time window end (UK format d-MMM-yy or ISO)" },
            "retrieved_at": { "type": "string", "description": "When this data was retrieved from source (UK format or ISO)" },
            "source": { "type": "string", "description": "Connection name used for this retrieval" },
            "path": { "type": "string", "enum": ["direct", "file"], "description": "How this data was retrieved: 'direct' = fetched directly from connection, 'file' = synced from parameter file" },
            "full_query": { "type": "string", "description": "Complete DSL query string used for this fetch (includes base query + window + context). Example: from(checkout).to(purchase).window(2025-01-01:2025-01-31).context(device:mobile)" },
            "debug_trace": { "type": "string", "description": "Complete execution trace as JSON string (request, response, query, connection_string, etc.) for debugging/provenance. May be truncated if response is very large." }
          },
          "$comment": "retrieved_at/source are strongly recommended but not required (synthetic/legacy graphs may omit them)."
        },
        "id": { "type": "string", "description": "Reference to parameter file (FK to parameter-{id}.yaml)" },
        "data_source": {
          "type": "object",
          "description": "Provenance information for this parameter",
          "additionalProperties": false,
          "properties": {
            "type": { 
              "type": "string", 
              "description": "Data source type (from connections.yaml, e.g., 'amplitude', 'sheets', 'manual')"
            },
            "retrieved_at": { "type": "string", "description": "When data was retrieved (UK format or ISO)" },
            "edited_at": { "type": "string", "description": "When data was last edited (UK format or ISO)" },
            "query": { "type": "object", "description": "Query object that produced this data" },
            "full_query": { "type": "string", "description": "Complete DSL query string used for retrieval" },
            "debug_trace": { "type": "string", "description": "Complete execution trace as JSON string for debugging/provenance" },
            "experiment_id": { "type": "string", "description": "Experiment/gate ID from A/B test platform (e.g., Statsig gate_id)" }
          },
          "required": ["type"]
        },
        "latency": { "$ref": "#/$defs/LatencyConfig" },
        "forecast": { "$ref": "#/$defs/ForecastParams" },
        "n": { 
          "type": "number", 
          "minimum": 0, 
          "description": "Forecast population for this edge under the current DSL. NOT the same as evidence.n (observed). Derived via step-wise convolution of upstream p.mean values. For anchor edges: equals evidence.n. For downstream edges: sum of inbound forecast.k at the from-node. Query-time value, recomputed when DSL or scenario changes."
        }
      }
    },

    "LatencyConfig": {
      "type": "object",
      "additionalProperties": false,
      "$comment": "Latency configuration for edges with time-delayed conversions. latency_parameter === true enables latency tracking.",
      "properties": {
        "latency_parameter": { "type": "boolean", "description": "Explicit enablement flag. true = latency tracking enabled." },
        "latency_parameter_overridden": { "type": "boolean", "default": false, "description": "If true, user manually set latency_parameter" },
        "anchor_node_id": { "type": "string", "description": "Anchor node for cohort queries (furthest upstream START)" },
        "anchor_node_id_overridden": { "type": "boolean", "default": false, "description": "If true, user manually set anchor_node_id" },
        "t95": { "type": "number", "minimum": 0, "description": "95th percentile lag in days (computed from fitted CDF)" },
        "t95_overridden": { "type": "boolean", "default": false, "description": "If true, user manually set t95" },
        "path_t95": { "type": "number", "minimum": 0, "description": "Critical path t95 in days (max t95 from anchor to this edge)" },
        "path_t95_overridden": { "type": "boolean", "default": false, "description": "If true, user manually set path_t95" },
        "onset_delta_days": { "type": "number", "minimum": 0, "description": "Onset delay in days - minimum time before conversions begin (aggregated from window slices)" },
        "onset_delta_days_overridden": { "type": "boolean", "default": false, "description": "If true, user manually set onset_delta_days" },
        "median_lag_days": { "type": "number", "minimum": 0, "description": "Weighted median lag in days (display only)" },
        "mean_lag_days": { "type": "number", "minimum": 0, "description": "Weighted mean lag in days (used with median to compute t95)" },
        "completeness": { "type": "number", "minimum": 0, "maximum": 1, "description": "Maturity progress 0-1 (display only)" }
      }
    },

    "ForecastParams": {
      "type": "object",
      "additionalProperties": false,
      "$comment": "Forecast probability parameters from mature cohorts. Note: mean can exceed 1.0 in edge cases when extrapolating from immature cohort data.",
      "properties": {
        "mean": { "type": "number", "minimum": 0, "description": "Forecast mean probability (p_∞) - can exceed 1.0 in edge cases" },
        "stdev": { "type": "number", "minimum": 0, "description": "Forecast standard deviation" },
        "k": { "type": "number", "minimum": 0, "description": "Expected converters on this edge (p.mean * p.n). Used for propagating population downstream." }
      }
    },

    "CostParam": {
      "type": "object",
      "additionalProperties": false,
      "$comment": "Cost structure (GBP monetary or time). Mirrors ProbabilityParam pattern with override flags and optional connection.",
      "properties": {
        "mean": { "type": "number", "minimum": 0 },
        "mean_overridden": { "type": "boolean", "default": false, "description": "If true, mean was manually edited and should not be auto-updated" },
        "stdev": { "type": "number", "minimum": 0 },
        "stdev_overridden": { "type": "boolean", "default": false, "description": "If true, stdev was manually edited and should not be auto-updated" },
        "distribution": { 
          "type": "string", 
          "enum": ["normal", "lognormal", "gamma", "uniform", "beta"],
          "default": "normal"
        },
        "distribution_overridden": { "type": "boolean", "default": false, "description": "If true, distribution was manually edited and should not be auto-updated" },
        "connection": { "type": "string", "description": "Connection name from connections.yaml" },
        "connection_overridden": { "type": "boolean", "default": false, "description": "If true, connection settings were manually edited and should not be auto-synced" },
        "connection_string": { "type": "string", "description": "JSON blob of provider-specific settings" },
        "evidence": {
          "type": "object",
          "description": "Observations from data sources (context for n/k, NOT overridable). Optional fields depend on source type.",
          "additionalProperties": false,
          "properties": {
            "n": { "type": "integer", "minimum": 0, "description": "Sample size (total trials) - required for cost data with observations" },
            "k": { "type": "integer", "minimum": 0, "description": "Number of successes/observations - optional" },
            "mean": { "type": "number", "minimum": 0, "description": "Evidence mean value (query-time computed scalar)" },
            "stdev": { "type": "number", "minimum": 0, "description": "Evidence standard deviation (query-time computed scalar)" },
            "window_from": { "type": "string", "description": "Time window start (UK format d-MMM-yy or ISO)" },
            "window_to": { "type": "string", "description": "Time window end (UK format d-MMM-yy or ISO)" },
            "retrieved_at": { "type": "string", "description": "When this data was retrieved from source (UK format or ISO)" },
            "source": { "type": "string", "description": "Connection name used for this retrieval" },
            "path": { "type": "string", "enum": ["direct", "file"], "description": "How this data was retrieved: 'direct' = fetched directly from connection, 'file' = synced from parameter file" },
            "full_query": { "type": "string", "description": "Complete DSL query string used for this fetch (includes base query + window + context)" },
            "debug_trace": { "type": "string", "description": "Complete execution trace as JSON string for debugging/provenance. May be truncated if response is very large." }
          },
          "$comment": "retrieved_at/source are strongly recommended but not required (synthetic/legacy graphs may omit them)."
        },
        "id": { "type": "string", "description": "Reference to cost parameter file (FK to parameter-{id}.yaml)" },
        "data_source": {
          "type": "object",
          "description": "Provenance information for this parameter",
          "additionalProperties": false,
          "properties": {
            "type": { 
              "type": "string", 
              "description": "Data source type (from connections.yaml, e.g., 'amplitude', 'sheets', 'manual')"
            },
            "retrieved_at": { "type": "string", "description": "When data was retrieved (UK format or ISO)" },
            "edited_at": { "type": "string", "description": "When data was last edited (UK format or ISO)" },
            "query": { "type": "object", "description": "Query object that produced this data" },
            "full_query": { "type": "string", "description": "Complete DSL query string used for retrieval" },
            "debug_trace": { "type": "string", "description": "Complete execution trace as JSON string for debugging/provenance" },
            "experiment_id": { "type": "string", "description": "Experiment/gate ID from A/B test platform (e.g., Statsig gate_id)" }
          },
          "required": ["type"]
        }
      },
      "required": ["mean"]
    },
    
    "Condition": {
      "type": "string",
      "pattern": "^(visited|exclude|context|case)\\(",
      "$comment": "Condition uses query DSL constraint syntax: visited(A,B), exclude(C), context(device:mobile), case(test:treatment). Can be combined with dots: visited(A).context(mobile). Most specific condition wins at runtime.",
      "description": "Constraint expression using query DSL syntax. Supported functions: visited(node-id,...) - path must include these nodes; exclude(node-id,...) - path must not include these nodes; context(key:value) - context must match; case(case-id:variant) - must be in this experiment variant where case-id is the Node.case.id value (preferred) or node.uuid (fallback), and variant is the variant name from case.variants.",
      "examples": [
        "visited(promo-viewed,feature-demo)",
        "exclude(cart-abandoned)",
        "context(device:mobile)",
        "case(checkout-experiment:treatment)",
        "visited(promo-viewed).context(device:mobile)"
      ]
    },
    
    "ConditionalProbability": {
      "type": "object",
      "additionalProperties": false,
      "$comment": "Conditional probability: probability that applies when specific condition is met. Condition is semantic (WHEN it applies), query is full retrieval path (HOW to fetch data). Query is auto-derived from condition + edge topology via MSMDC, but can be manually overridden.",
      "required": ["condition", "p"],
      "properties": {
        "condition": { "$ref": "#/$defs/Condition" },
        "colour": {
          "type": "string",
          "pattern": "^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$",
          "description": "Display-only colour for this conditional branch (editor UI)."
        },
        "query": {
          "type": "string",
          "pattern": "^from\\([a-z0-9_-]+\\)\\.to\\([a-z0-9_-]+\\)",
          "description": "Full data retrieval query (auto-derived from condition + edge topology). Example: from(checkout).to(purchase).visited(promo)"
        },
        "query_overridden": {
          "type": "boolean",
          "default": false,
          "description": "If true, query was manually edited and should not be auto-regenerated by MSMDC"
        },
        "p": { "$ref": "#/$defs/ProbabilityParam" }
      }
    },
    
    "EdgeDisplay": {
      "type": "object",
      "additionalProperties": false,
      "$comment": "Display parameters for edges (not semantic, used by editor)",
      "properties": {
        "conditional_colour": { 
          "type": "string", 
          "pattern": "^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})$",
          "description": "User-selected colour override for conditional edges"
        },
        "conditional_group": { 
          "type": "string", 
          "maxLength": 128,
          "description": "Optional user-defined group for conditional colour assignment"
        }
      }
    },

    "Costs": {
      "$comment": "DEPRECATED: This nested structure is no longer used. Use flat cost_gbp and labour_cost fields on edges instead (both use CostParam). Kept for backward compatibility only.",
      "type": "object",
      "additionalProperties": false,
      "deprecated": true,
      "properties": {
        "monetary": { "$ref": "#/$defs/MonetaryCost" },
        "time": { "$ref": "#/$defs/TimeCost" }
      }
    },

    "MonetaryCost": {
      "$comment": "DEPRECATED: No longer used. Use cost_gbp (CostParam) on edges instead. Currency is implicitly GBP.",
      "type": "object",
      "additionalProperties": false,
      "deprecated": true,
      "properties": {
        "value": { "type": "number", "minimum": 0 },
        "stdev": { "type": "number", "minimum": 0 },
        "distribution": { 
          "type": "string", 
          "enum": ["normal", "lognormal", "gamma", "uniform"],
          "default": "normal"
        },
        "currency": { 
          "type": "string", 
          "enum": ["GBP", "USD", "EUR"],
          "default": "GBP"
        }
      },
      "required": ["value"]
    },

    "TimeCost": {
      "$comment": "DEPRECATED: No longer used. Use labour_cost (CostParam) on edges instead. Units are implicitly days.",
      "type": "object",
      "additionalProperties": false,
      "deprecated": true,
      "properties": {
        "value": { "type": "number", "minimum": 0 },
        "stdev": { "type": "number", "minimum": 0 },
        "distribution": { 
          "type": "string", 
          "enum": ["normal", "lognormal", "gamma", "uniform"],
          "default": "lognormal"
        },
        "units": { 
          "type": "string", 
          "enum": ["days", "hours", "weeks"],
          "default": "days"
        }
      },
      "required": ["value"]
    },

    "ResidualBehavior": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "default_outcome": { "type": "string", "minLength": 1 },
        "overflow_policy": {
          "type": "string",
          "enum": ["error", "normalize", "cap"],
          "default": "error"
        }
      }
    },

    "Policies": {
      "type": "object",
      "required": ["default_outcome"],
      "additionalProperties": false,
      "properties": {
        "default_outcome": { "type": "string", "minLength": 1 },
        "overflow_policy": {
          "type": "string",
          "enum": ["error", "normalize", "cap"],
          "default": "error"
        },
        "free_edge_policy": {
          "type": "string",
          "enum": ["complement", "uniform", "weighted"],
          "default": "complement"
        }
      }
    },

    "Metadata": {
      "type": "object",
      "required": ["version", "created_at"],
      "additionalProperties": false,
      "properties": {
        "version": { "type": "string", "pattern": "^\\d+\\.\\d+\\.\\d+$" },
        "name": { 
          "type": "string", 
          "maxLength": 256,
          "description": "Human-readable graph name for display in UI"
        },
        "created_at": { "type": "string", "description": "Creation timestamp (UK format or ISO)" },
        "updated_at": { "type": "string", "description": "Last update timestamp (UK format or ISO)" },
        "last_retrieve_all_slices_success_at_ms": {
          "type": "number",
          "minimum": 0,
          "description": "Cross-device marker: epoch ms when a full Retrieve All Slices run completed successfully for this graph."
        },
        "author": { "type": "string", "maxLength": 256 },
        "description": { "type": "string" },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "uniqueItems": true
        }
      }
    }
  }
}
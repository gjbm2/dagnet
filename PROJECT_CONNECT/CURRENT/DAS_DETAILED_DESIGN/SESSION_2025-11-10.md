# DAS Implementation Session - November 10, 2025

## Overview
Major session completing Amplitude integration debugging and designing/implementing the inclusion-exclusion algorithm for providers lacking native exclude support.

---

## Part 1: Amplitude Integration Debugging (Completed)

### Issues Resolved

1. **Event Property Filter Correction**
   - Issue: Filters using `property: "value"` returned 0 results
   - Root cause: Actual Amplitude property name is `"level"` (lowercase)
   - Fix: Updated `delegation-completed.yaml` to use correct property name
   - Result: Filters now work; query returns k=906 with filters applied

2. **Amplitude API Parameter Validation**
   - Systematically tested GET /funnels parameters via curl
   - Found: `m=uniques` causes 500 error (rejected by API)
   - Found: `i=1` works fine (interval mode)
   - Fix: Removed `m=uniques` from query builder in `connections.yaml`
   - Result: GET requests succeed with 200 OK

3. **JMESPath Extraction Correction**
   - Issue: Extraction paths targeted non-existent `data.steps[i].count`
   - Actual structure: `data[0].cumulativeRaw[i]`
   - Fix: Updated extraction paths in `connections.yaml`
   - Result: Counts extracted correctly (n=1471, k=906 with filters)

### End-to-End Amplitude Integration Status
✅ **WORKING:** Full pipeline from UI click → event mapping → query compilation → API call → extraction → graph update

**Validated workflow:**
1. Click lightning icon on parameter
2. Event IDs loaded from IDB (household-created, delegation-completed)
3. Provider event names mapped (Household Created, ServiceLevel Confirmed)
4. Filters applied (level IN [DO_MOST_OF_IT_FOR_ME, DO_ALL_OF_IT_FOR_ME])
5. GET request via proxy with correct auth
6. Response: 200 OK, data extracted
7. Graph updated: p.mean, p.evidence.n, p.evidence.k

---

## Part 2: Exclude/Subtraction Deep Dive (Major Design Work)

### The Problem Discovery

Testing revealed that Amplitude's Dashboard REST GET endpoint:
- ✅ Supports: ordered funnels, visited(), filters, date windows
- ❌ Does NOT support: `ex=` (exclude) parameter (tested exhaustively via curl)

This created a fundamental problem: how to measure edge probabilities in graphs with competing paths when the provider lacks exclude support?

### Design Evolution (Multiple Iterations)

#### Iteration 1: Naive Subtraction (FAILED)
- Attempted: One minus per competing first hop
- Example: `minus(from(a).to(b).visited(b))` ← nonsense!
- Why failed: Incorrect from/to anchors

#### Iteration 2: Global Minus on Merge (FAILED)  
- Attempted: `minus(from(a).to(m).visited(b))` for all first hops
- Why failed: Overlapping paths (a→f→b→m counted in both `visited(f)` AND `visited(b)`)
- Over-subtraction: 466.67 on 800.00 actual (58% error)

#### Iteration 3: MECE Path Enumeration (FAILED)
- Attempted: One minus per simple path's exact interior
- Example: 9 terms for 9 non-direct paths
- Why failed: Amplitude's `visited(x,y)` means "contains x AND y somewhere", NOT "interior equals exactly [x,y]"
- Over-subtraction: 1266.67 on 800.00 actual (58% error)

#### Iteration 4: Inclusion-Exclusion (SUCCESS) ✅
- Insight: With visited() = "contains" semantics, bins overlap; need add-backs
- Formula: k = k_base − Σ|singles| + Σ|pairs| − Σ|triples| + ...
- Implementation: Alternating signs by subset size
- Optimization: Prune unreachable combinations (40% reduction)
- Validation: Flow conservation test with 1000-user distribution
- Result: EXACT (computed 800.00 = actual 800.00)

### Mathematical Proof

**Flow Test (Complex Graph):**
```
Nodes: a, b, d, e, f, g, m
Edges: a→m, a→b→m, a→f→b, a→f→g→m, a→e→b, a→e→g, a→d→m, a→d→g→m, a→d→e→...
Start: 1000 users at a
Distribution: Equal split at each branch (1/R per outgoing edge)
```

**Results:**
- Direct a→m: 200.00
- All non-direct paths: 800.00
- Inclusion-exclusion computed: 800.00 (EXACT)
- Terms: 9 (after reachability pruning from 15)

**Query generated:**
```
from(a).to(m)
  .minus(from(a).to(m).visited(b))
  .minus(from(a).to(m).visited(d))
  .minus(from(a).to(m).visited(e))
  .minus(from(a).to(m).visited(f))
  .plus(from(a).to(m).visited(b).visited(d))
  .plus(from(a).to(m).visited(b).visited(e))
  .plus(from(a).to(m).visited(b).visited(f))
  .plus(from(a).to(m).visited(d).visited(e))
  .minus(from(a).to(m).visited(b).visited(d).visited(e))
```

### Algorithm: Optimized Inclusion-Exclusion

**Core logic:**
1. Enumerate competing first hops: H = {nodes from source with paths to target}
2. Generate reachable combinations (prune impossible node sets)
3. Build terms with alternating signs:
   - Size 1: minus (coefficient -1)
   - Size 2: plus (coefficient +1)  
   - Size 3: minus (coefficient -1)
   - etc.
4. Execute all terms in parallel
5. Combine: k = k_base + Σ(coeff_i × to_count_i)

**Optimizations:**
- Reachability pruning: Skip combinations with no paths containing all nodes
- Dominance elimination: Remove first hops dominated by others
- Typical reduction: 40-60% fewer terms

### Critical Design Decisions

1. **Merge = Target for Edge Discrimination**
   - Edge a→b measures P(users go from a to b)
   - NOT P(users reach downstream point via b)
   - This was a key bug caught by random graph tests

2. **Both minus() and plus() Required**
   - Cannot compress to fewer terms without add-backs
   - Tried multiple compression algorithms; all fail without exclusivity primitive

3. **DSL Remains Order-Independent**
   - minus/plus are constraint operators like visited/exclude
   - Token order irrelevant (commutative algebra)

---

## Part 3: Implementation Completed

### Python (MSMDC)
- ✅ `msmdc/algorithms/graph_analysis.py` - core compilation logic
- ✅ `msmdc/algorithms/optimized_inclusion_exclusion.py` - optimized algorithm
- ✅ `msmdc/algorithms/test_inclusion_exclusion.py` - pytest suite
  - 4 deterministic tests (simple, diamond, complex, native exclude)
  - 10 random 20-node DAG tests with flow validation
  - **All 14 tests pass**

### Schemas & Types
- ✅ `query-dsl-1.0.0.json` - added "minus" and "plus" to valid functions
- ✅ `lib/query_dsl.py` - Python parser with recursive minus/plus extraction
- ✅ `graph-editor/src/lib/queryDSL.ts` - TypeScript constants updated

### TypeScript Runtime
- ✅ `compositeQueryParser.ts` - parse minus/plus terms from DSL strings
- ✅ `compositeQueryExecutor.ts` - parallel execution + weighted combination
- ✅ `dataOperationsService.ts` - integrated composite query path
- ✅ `QueryExpressionEditor.tsx` - Monaco support for minus/plus (chip parsing, autocomplete)

### Documentation
- ✅ `DAS_DSL_EXCLUDES_AND_SUBTRACTION.md` - mathematical foundation
- ✅ `DAS_SUBTRACTION_IMPLEMENTATION_PLAN.md` - full implementation roadmap
- Both updated with proven inclusion-exclusion approach

---

## Key Learnings

### What Worked
- **Flow-based validation:** 1000-user distribution test caught every algorithmic error
- **Random graph stress tests:** Exposed edge cases (merge≠target bug) that manual tests missed
- **Iterative refinement:** Each failed approach taught us something about the constraints

### What Was Hard
- **Semantic impedance:** Amplitude's visited() ≠ our path discrimination needs
- **No escape hatch:** GET endpoint lacks primitives we need (exclude, between_exact)
- **Exactness requirement:** Approximations not acceptable for Bayesian inference
- **Multiple algorithm attempts:** 4 major iterations before finding the correct solution

### Complexity Assessment
- This level of abstract complexity (inclusion-exclusion, flow proofs, graph algorithms) is rare
- Comparable to: compiler optimization, database query planning, constraint solving
- Not typical in: web apps, CRUD systems, UI development
- Necessary here due to: mathematical rigor requirements + provider API limitations

---

## Phase Status

### Phase 1: Foundation ✅ COMPLETE
- All schemas updated
- Parsers implemented (Python + TypeScript)
- Test infrastructure in place

### Phase 2: MSMDC Algorithms ✅ COMPLETE
- Optimized inclusion-exclusion implemented
- Flow-validated on complex graphs
- Pytest suite: 14/14 passing (including 10 random DAGs)

### Phase 3: Runtime Execution ✅ COMPLETE
- Composite query parser implemented
- Parallel execution with coefficient weighting
- Integrated into dataOperationsService
- Monaco editor updated

### Phase 4: Integration & Testing (NEXT)
- End-to-end test with real Amplitude data
- Performance validation
- Production deployment

---

## Technical Debt / Follow-up

1. **Monaco UX for nested queries:** Chip rendering for complex minus/plus may need refinement
2. **Performance monitoring:** Track term count distribution in production
3. **Cache consideration:** Only add if profiling shows >30% sub-query duplication
4. **Error messages:** User-friendly explanations when queries fail
5. **Documentation:** User guide for when/why complex queries are generated

---

## Files Created/Modified

**New Files:**
- `msmdc/algorithms/graph_analysis.py`
- `msmdc/algorithms/optimized_inclusion_exclusion.py`
- `msmdc/algorithms/inclusion_exclusion.py`
- `msmdc/algorithms/test_inclusion_exclusion.py`
- `msmdc/algorithms/test_graph_analysis.py`
- `graph-editor/src/lib/das/compositeQueryParser.ts`
- `graph-editor/src/lib/das/compositeQueryExecutor.ts`
- `graph-editor/docs/DAS_DSL_EXCLUDES_AND_SUBTRACTION.md`
- `graph-editor/docs/DAS_SUBTRACTION_IMPLEMENTATION_PLAN.md`

**Modified Files:**
- `graph-editor/public/schemas/query-dsl-1.0.0.json`
- `lib/query_dsl.py`
- `graph-editor/src/lib/queryDSL.ts`
- `graph-editor/src/services/dataOperationsService.ts`
- `graph-editor/src/components/QueryExpressionEditor.tsx`
- `param-registry/test/events/delegation-completed.yaml`
- `graph-editor/public/defaults/connections.yaml`

**Deleted Files:**
- `msmdc/algorithms/debug_seed.py` (temporary debug script)

---

## Next Session Goals

### Critical for Amplitude Production
1. **Cohort Exclusion** ✅ **IMPLEMENTED** - exclude internal test users (cohort_id: `9z057h6i`)
   - ✅ Researched API parameter: confirmed `s=` segmentation with JSON format
   - ✅ Implemented in amplitude-prod connection (connections.yaml)
   - ⏭️ Next: Test with curl to validate with live API

2. **Case/Variant Filtering** - query by experiment variants
   - Design case property mapping schema
   - Extend event definitions
   - Implement in pre_request script

### Testing & Validation
3. End-to-end test of composite queries against Amplitude (simple diamond first)
4. Validate Monaco editor UX for minus/plus operators
5. Performance benchmarking (target: <2s for 10-term query)

### Polish
6. Production deployment preparation
7. User documentation

---

## Session Epilogue: Auto-Rebalancing Sibling Parameters

**Problem**: When external data updates one parameter (e.g., `p(A>B) = 0.3` from Amplitude), sibling parameters should automatically rebalance if not overridden.

**Use Case**: 
- Graph: A→B, A→C
- A→B gets data: `p = 0.3`
- A→C has no event tracking (commercially defined as "no event")
- **Desired**: `p(A>C)` should auto-compute as `1 - 0.3 = 0.7`

**Implementation**:
1. **New utility**: `rebalanceSiblingParameters()` in `rebalanceUtils.ts`
2. **Integration**: Called automatically after `handleExternalToGraph()` in `dataOperationsService.ts`
3. **Logic**:
   - Find all sibling parameters (same parent node OR same conditional_p condition)
   - Separate overridden vs non-overridden
   - Calculate `remaining_weight = 1 - sum(overridden_weights)`
   - Pro-rate `remaining_weight` proportionally across non-overridden siblings
   - Fallback to equal distribution if all non-overridden are zero

**Example Scenarios**:

```typescript
// Scenario 1: Simple two-sibling case
A→B: p=0.3 (from data)
A→C: p=? (not overridden)
Result: A→C = 0.7

// Scenario 2: Three siblings, one overridden
A→B: p=0.3 (from data, not overridden)
A→C: p=0.5 (manually overridden)
A→D: p=? (not overridden)
Result: A→D = 1 - 0.3 - 0.5 = 0.2

// Scenario 3: Multiple non-overridden siblings
A→B: p=0.3 (from data, not overridden)
A→C: p=0.4 (not overridden, gets pro-rated)
A→D: p=0.3 (not overridden, gets pro-rated)
Remaining: 1 - 0.3 = 0.7
Current total: 0.4 + 0.3 = 0.7
Result: A→C = 0.4/0.7 * 0.7 = 0.4
        A→D = 0.3/0.7 * 0.7 = 0.3
```

**Impact**: Massively reduces manual work - graphs become self-maintaining when data flows in.

---

## Metrics

- **Time investment:** ~6 hours (includes all false starts and iterations)
- **Lines of code:** ~2000 (including tests and docs)
- **Test coverage:** 14 automated tests, all passing
- **Algorithm iterations:** 4 major approaches before success
- **Documentation:** 2 comprehensive design documents

---

*Session completed: 2025-11-10*
*Status: Amplitude integration working; inclusion-exclusion algorithm proven and implemented*


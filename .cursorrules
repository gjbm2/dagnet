# DagNet Development Guidelines for AI Assistants

## Language and Formatting Standards

### UK English
- Use UK spellings throughout: colour, behaviour, centre, organisation, realise, analyse, etc.
- Exception: Code identifiers may use US spelling if that's the existing convention in external APIs

### Date Format
- **ALWAYS** use `d-MMM-yy` format: `1-Dec-25`, `15-Jan-24`, `7-Mar-26`
- Never use `YYYY-MM-DD` (ISO) or `MM/DD/YYYY` (US) in UI, logs, or file storage
- **Only exception**: External API boundaries may require ISO format - convert immediately after receipt

### Python / Virtualenv (REQUIRED)
- **ALWAYS** activate the repo venv before running any Python commands: `graph-editor/venv`
- In terminal tool calls, prefix Python steps with: `. graph-editor/venv/bin/activate`
- Use the venv executables (`python`, `python3`, `pip`, etc.) from `graph-editor/venv` (i.e. `which python3` must resolve inside the venv), not the system interpreter.

### Node / npm (repo-pinned via nvm)
- Node major version is pinned in `graph-editor/.nvmrc` (currently `22`).
- In some environments `npm` is not on PATH until **nvm is sourced**.
- **Technique (no repo scripts required)**:
  - `export NVM_DIR="$HOME/.nvm"`
  - `. "$NVM_DIR/nvm.sh"` (only if it exists)
  - `cd graph-editor && nvm use "$(cat .nvmrc)"`
  - After this, `node` and `npm` should be available for `npm test`, etc.

## Core Principles

### 0. SYSTEMATIC CAUTION UNTIL FULL CONTEXT IS UNDERSTOOD
**CRITICAL**: Do not make behavioural or semantic changes (especially caching, query semantics, data shape, or persistence) until you have absorbed the *relevant* code context end-to-end.

This repo is large and subtle; over-confidence causes regressions. The assistant must default to *cautious, systematic* work.

**Before proposing or implementing a semantic change** (e.g. “X should be part of the cache signature”):
- **TRIPLE-SEARCH** the repo for existing implementations and prior decisions (`grep` + `codebase_search`), including docs in `docs/current/`.
- **Trace the full path** for the behaviour: UI entry points → hooks → services → storage/adapters → caches → persistence formats.
- **Identify all call sites** and *all* related “signature/key” mechanisms (often there are multiple caches with different purposes).
- **Read relevant project context docs first**: `docs/current/project-contexts/` and any referenced design docs.
- **Write down the invariants** you believe the system relies on (e.g. what is expected to invalidate cache vs remain stable).

**Uncertainty discipline**:
- If you are not sure, **say so explicitly** and ask clarifying questions *before changing code*.
- Avoid definitive language like “this is correct”, “done”, “fixed” until confirmed by code inspection and relevant tests.
- Prefer: “I believe…”, “Based on the current implementation…”, “I haven’t yet confirmed X; next I will…”.

**Change discipline**:
- Make the **smallest** change that accomplishes the intent.
- Re-check assumptions after reading each key module (e.g. where the query payload is constructed, where signatures are computed, where caches are consumed).
- After changes, **run only the relevant tests** and do not claim success until they pass.

### 0.5 APPROVAL + RISK DISCIPLINE (NO “CODE FIRST, ASK LATER”)
**CRITICAL**: Shift judgement away from “code first, ask questions later”.

This section is about **behavioural/source-code changes** and other changes with meaningful blast radius. It is **not** intended to add bureaucracy to routine documentation edits.

**Default posture**:
- Prefer **explicit agreement** before making behavioural/source-code changes.
- If agreement is not yet clear, **pause** and ask clarifying questions first.

**When it is OK to write code**:
- **Explicit approval**: the user says “yes/go ahead/approved”, etc.
- **Agreed plan**: you wrote a prose implementation plan, the user agreed, and you stay strictly in-scope.
- **High-confidence, fully-understood change**: you have traced the relevant end-to-end code path, identified call sites and invariants, considered unintended consequences, and stated a brief **risk assessment** (why it is low/medium/high risk). If risk is not low, get explicit approval.

**What this discipline applies to**:
- **Behavioural changes** in `.ts/.tsx/.js/.py/.ps1/.sh/.yaml/.json` that affect runtime logic, persistence, caches, data shape, git/file ops, scheduling, credentials, or external calls
- Terminal commands that **modify state** (installs, migrations, checkouts/resets, codegen, etc.)
- “Small UI copy tweaks” that actually change behaviour (e.g. default actions, automatic execution, safety prompts)

**What it does NOT apply to (by default)**:
- Routine edits to `.md` docs and notes that do not change behaviour or operational safety.
  - If a doc change is effectively a design/behaviour decision, treat it like a behavioural change: write a plan and get agreement.

**If you realise you started coding without sufficient agreement**:
- Stop immediately.
- Show exactly what changed (`git diff` / precise regions).
- Ask the user how they want it reverted; do not do broad resets without consent.

### 1. NO LOGIC IN UI/MENU FILES
**CRITICAL**: Menu files, context menus, and UI components are ACCESS POINTS ONLY.

- ✅ **DO**: Call centralized service methods or hooks
- ✅ **DO**: Create a hook if same operation appears in multiple menus
- ❌ **DON'T**: Implement business logic inline
- ❌ **DON'T**: Duplicate logic across multiple call sites
- ❌ **DON'T**: Put git operations, file operations, validation, or data transformations in UI files
- ❌ **DON'T**: Copy/paste handlers between NavigatorItemContextMenu, TabContextMenu, and FileMenu

**Example - WRONG**:
```typescript
// FileMenu.tsx - BAD!
const handleCommit = async () => {
  const credsResult = await credentialsManager.loadCredentials();
  const gitCreds = credsResult.credentials.git.find(...);
  const result = await gitService.commitAndPushFiles(...);
  // 50 more lines of logic...
}
```

**Example - CORRECT**:
```typescript
// FileMenu.tsx - GOOD!
const handleCommit = async () => {
  await repositoryOperationsService.commitFiles(files, message, branch, repo, showConfirm);
}
```

**For operations appearing in multiple menus, create a hook**:
```typescript
// hooks/usePullFile.ts - Centralized hook
export function usePullFile(fileId: string | undefined) {
  const { canPull, pullFile } = /* ... service calls ... */;
  return { canPull, pullFile };
}

// All menus use the same hook:
// NavigatorItemContextMenu.tsx, TabContextMenu.tsx, FileMenu.tsx
const { canPull, pullFile } = usePullFile(fileId);
```

### 2. NEVER CREATE DUPLICATE CODE PATHS
**CRITICAL**: Multiple code paths to achieve the same thing cause GRAVE HARM.

Before creating ANY new functionality:

1. **TRIPLE CHECK** for existing implementations - Use `grep` or `codebase_search` exhaustively
2. **Favor generalizing existing code** over creating new paths - Ask user if unsure
3. **If similar functionality exists**, extend it rather than duplicate
4. **Check all call sites** - If updating a service method, check ALL places it's called
5. **Trace the full path** - Understand the complete flow from UI → Service → Storage

**Required checks before writing new code**:
- [ ] TRIPLE-searched codebase for similar functionality
- [ ] Checked if a service already handles this operation
- [ ] Identified all existing call sites
- [ ] Verified no duplicate implementations exist
- [ ] If plausible existing path exists, generalized it instead of creating new

**If in doubt**: ASK THE USER before creating a new code path. Duplicate paths are the Devil's work.

### 3. CENTRALIZE SHARED CODE
**Services are the single source of truth** for business logic:

- `repositoryOperationsService.ts` - Git operations (pull, push, commit, clone, status)
- `fileOperationsService.ts` - File CRUD (create, open, delete, duplicate, rename)
- `dataOperationsService.ts` - Data sync (Get/Put between files ↔ graph ↔ external sources)
- `workspaceService.ts` - IndexedDB workspace management
- `gitService.ts` - Direct GitHub API calls
- `indexRebuildService.ts` - Index file management

**If logic is used in multiple places**, it MUST be in a service, NOT duplicated.

### 4. ALWAYS UPDATE TESTS
When modifying functionality:

1. **Update existing tests** - Don't leave tests broken or outdated
2. **CRITICAL: Do not weaken tests without explicit approval**
   - Updating tests **as part of an agreed scope/design change** is allowed and expected.
   - However, any test change that could **soften coverage** or reduce safety requires **explicit approval**.
   - Examples that require explicit approval: loosening assertions, widening tolerances, removing/weakening scenarios, snapshot updates that remove important signal.
   - Non-softening updates (e.g. aligning expectations with an explicitly agreed behaviour change, adding assertions, fixing deterministic failures) do not require a separate approval step beyond the approved change scope.
3. **Prefer editing existing test files over creating new ones**
   - The intent of the authorisation rule is to prevent silent weakening of test coverage, **not** to force test-file proliferation.
   - If a change needs new assertions, the assistant should normally add them to the most relevant existing test file/suite.
   - Only create a brand-new test file when there is no sensible existing home (e.g. no suite exists for that module/behaviour).
   - **NO NEW TEST FILES** unless there is **manifestly no better place** for the test. Default to extending the most relevant existing suite.
4. **Add new tests** - For new functionality or bug fixes
5. **Run RELEVANT tests only** - Don't run full suite unless explicitly asked
6. **Check integration tests** - Only if changes affect integration points

Test files are in:
- `graph-editor/src/services/__tests__/` - Service integration tests
- `graph-editor/tests/` - Higher-level integration tests

### 5. DATA SOURCES OF TRUTH

**IndexedDB is the source of truth** for:
- File content and dirty state
- Git SHAs and metadata
- Workspace state

**FileRegistry is an in-memory cache**:
- Used for performance (open tabs)
- NOT the source of truth for dirty files or git operations
- Must sync with IndexedDB

**Critical**: Always use `db.getDirtyFiles()` for git operations, NOT `fileRegistry.getDirtyFiles()`.

### 6. SESSION LOGGING FOR EXTERNAL/DATA OPERATIONS
**CRITICAL**: All operations interacting with external systems or data must have session logging.

Operations requiring session logging:
- **Git operations**: clone, pull, push, commit, rollback, fetch history
- **File operations**: create, delete, rename, duplicate, rollback
- **Data operations**: get from source, put to file, clear data, sync
- **Workspace operations**: clone, load, rollback, sync

Use `sessionLogService` from `services/sessionLogService.ts`:

```typescript
import { sessionLogService } from '../services/sessionLogService';

// Info - operation starting
sessionLogService.info('git', 'GIT_PULL', `Pulling latest from ${repo}/${branch}`, undefined, { repo, branch });

// Success - operation completed
sessionLogService.success('git', 'GIT_PULL_SUCCESS', `Pulled ${filesChanged} files`, detail, { repo, branch });

// Error - operation failed
sessionLogService.error('git', 'GIT_PULL_ERROR', `Pull failed: ${message}`, undefined, { repo, branch });

// Warning - operation completed with issues
sessionLogService.warning('git', 'GIT_PULL_CONFLICTS', `Pull completed with ${count} conflicts`, detail, metadata);

// Hierarchical logging for complex operations
const logOpId = sessionLogService.startOperation('info', 'git', 'GIT_COMMIT', `Committing to ${repo}`);
sessionLogService.addChild(logOpId, 'info', 'COMMIT_FILE', `Updated: ${path}`);
sessionLogService.endOperation(logOpId, 'success', 'Committed N files');
```

Operation types: `'session' | 'git' | 'file' | 'workspace' | 'msmdc' | 'data-fetch' | 'data-update' | 'graph' | 'index' | 'merge' | 'integrity'`

## Architecture Patterns

### Service Layer Pattern
```typescript
// 1. UI calls service (no business logic in UI)
const handleAction = async () => {
  await someService.doOperation(params, callbacks);
};

// 2. Service contains all business logic
class SomeService {
  async doOperation(params, callbacks) {
    // Load data
    // Validate
    // Transform
    // Show dialogs (via callback)
    // Execute operation
    // Update state
    // Notify listeners
  }
}
```

### Callback Pattern for UI Interactions
Services should NOT import UI components or dialogs directly.
Instead, accept callbacks:

```typescript
// Service
async commitFiles(
  files: any[],
  message: string,
  branch: string,
  repository: string,
  showConfirmDialog: (options: any) => Promise<boolean>  // ← Callback
): Promise<void>

// UI calls service with its own showConfirm
await repositoryOperationsService.commitFiles(
  files, message, branch, repo, 
  showConfirm  // ← From useDialog() hook
);
```

### Index File Requirements
- Index files MUST be at root: `nodes-index.yaml`, `parameters-index.yaml` (plural names)
- Data files MUST be in subdirectories: `nodes/my-node.yaml`, `parameters/my-param.yaml`
- Index files use workspace-prefixed IDs in IndexedDB: `repo-branch-node-index`
- Index files must be marked `isDirty: true` when modified

## Common Pitfalls to Avoid

1. **Don't put git/file operations in menu files**
   - Move to `repositoryOperationsService` or `fileOperationsService`

2. **Don't duplicate logic across menus**
   - If NavigatorItemContextMenu, TabContextMenu, and FileMenu need the same operation:
     1. Create a service method in `repositoryOperationsService` or `fileOperationsService`
     2. Create a hook in `hooks/` that wraps the service call with state/error handling
     3. Use that hook in all three menus
   - Examples: `usePullFile`, `useCommitHandler`, `useDeleteFile`

3. **Don't duplicate validation logic**
   - Create a centralized validation function

4. **Don't trust FileRegistry for dirty state in git operations**
   - Use `db.getDirtyFiles()` which queries IndexedDB

5. **Don't forget workspace prefixes for IndexedDB**
   - Files in IDB: `repo-branch-fileId`
   - Files in FileRegistry: `fileId` (unprefixed)

6. **Don't skip updating tests when changing functionality**
   - Update existing tests
   - Add new tests for bug fixes
   - Run relevant tests (not full suite)

7. **Don't create helper scripts for testing**
   - Use proper Vitest integration tests
   - Mock external APIs (GitHub)
   - Use real internal components (IndexedDB, FileRegistry)

## Testing Standards

### Integration Test Structure
```typescript
describe('Feature Integration Tests', () => {
  beforeEach(async () => {
    // Setup mocks
    vi.clearAllMocks();
    // Reset state
  });

  it('should handle complete flow end-to-end', async () => {
    // Arrange: Setup test data
    // Act: Execute operation
    // Assert: Verify all side effects
  });
});
```

### Critical Test Coverage
- Git operations (clone, pull, push, commit)
- File operations (create, open, delete, dirty tracking)
- Index operations (create, rebuild, add entries)
- Data sync (file ↔ graph ↔ external sources)
- Merge conflicts (3-way merge, resolution)

## File Structure Requirements

- Services: `graph-editor/src/services/`
- Tests: `graph-editor/src/services/__tests__/` and `graph-editor/tests/`
- UI Components: `graph-editor/src/components/`
- Contexts: `graph-editor/src/contexts/`
- Types: `graph-editor/src/types/`

## Documentation Structure

### User-Facing Documentation
**Location:** `graph-editor/public/docs/`

User guides, references, and changelogs accessible in-app and on GitHub:
- `user-guide.md` - Getting started and core concepts
- `query-expressions.md` - Query DSL reference
- `api-reference.md` - Programmatic access
- `keyboard-shortcuts.md` - Productivity tips
- `CHANGELOG.md` - Release history

### Technical Documentation
**Location:** `docs/`

Developer and architecture documentation:

1. **Current Docs** (`docs/current/`)
   - Active technical specs
   - Architecture decisions
   - **Project Contexts** (`docs/current/project-contexts/`) - ALWAYS check here for current work plans and system status

2. **Component Docs** (`graph-editor/docs/`)
   - Component-specific technical documentation
   - Setup guides (e.g., `AMPLITUDE_CREDENTIALS_SETUP.md`)
   - Testing guides (`INTEGRATION_TESTING_GUIDE.md`, `TESTING_STRATEGY.md`)

3. **Archive** (`docs/archive/`)
   - Historical documentation
   - Completed work - useful for understanding design decisions

### When Making System Changes

**ALWAYS check relevant docs BEFORE making changes:**
1. Check `docs/current/project-contexts/` for current project status
2. Search `docs/current/` for architecture decisions
3. Search `docs/archive/` for historical context on design decisions
4. Update `graph-editor/public/docs/` if user-facing behavior changes

## Code Quality Checklist

Before submitting changes:
- [ ] No business logic in UI/menu files
- [ ] All shared logic centralized in services
- [ ] Tests updated and passing
- [ ] No duplicate code paths
- [ ] IndexedDB is source of truth for git operations
- [ ] Index files use correct paths (root, plural names)
- [ ] Workspace prefixes handled correctly
- [ ] All call sites updated consistently

## When Making Changes

1. **Understand the full context**
   - Trace the complete code path
   - Identify all call sites
   - Check for existing implementations

2. **Centralize first**
   - Move logic to services
   - Update all call sites to use the service
   - Remove duplicate implementations

3. **Test thoroughly**
   - Update existing tests
   - Add new tests for changes
   - Run relevant tests only
   - Verify no regressions

4. **Verify consistency**
   - Check all UI entry points use same code path
   - Ensure dialogs show same information
   - Verify all file operations update IndexedDB

### Adding New Fields or Features - FULL IMPACT ASSESSMENT

**CRITICAL**: When adding a new field (e.g., `n_query`), you MUST check ALL places where similar fields are handled.

**Required checklist for new fields:**
- [ ] **TypeScript types** (`src/types/index.ts`) - Add to relevant interfaces
- [ ] **Python Pydantic models** (`lib/graph_types.py`) - Add to relevant models
- [ ] **YAML schemas** (`public/param-schemas/`) - Add field definitions
- [ ] **Service types** (`src/services/*Service.ts`) - Add to any service-specific interfaces
- [ ] **UI components** - PropertiesPanel, editors that display/edit the field
- [ ] **UpdateManager** - If field contains node references, update on node ID rename
- [ ] **Services** - Storage, retrieval, sync logic (dataOperationsService, etc.)
- [ ] **Override patterns** - If field has `_overridden` companion, mirror the pattern

**Finding companion fields**: When adding `new_field`, search for similar fields like `query`:
```bash
grep -r "query_overridden\|\.query\b" --include="*.ts" --include="*.tsx" --include="*.py" --include="*.yaml"
```
Then ensure `new_field` follows the SAME patterns in ALL the same places.

**Common patterns that must be mirrored:**
- `field` + `field_overridden` pair (mastered on graph, copied to file)
- UpdateManager node ID replacement for query strings
- PropertiesPanel display/edit with blur-to-save pattern
- Service layer push to file + fallback from file

**Test coverage for new fields:**
- [ ] Check existing tests in `src/services/__tests__/` that test similar fields
- [ ] Add tests for storage/retrieval of the new field
- [ ] Add tests for override behavior if applicable
- [ ] Add tests for UpdateManager node ID replacement if field contains node references
- [ ] Run ONLY the relevant tests (not full suite) to verify no regressions

## Key Lessons from Recent Bugs

1. **Index files were being built in wrong locations**
   - Root cause: Inconsistent path handling across services
   - Fix: Single source of truth for index file paths
   - Tests: Added integration tests for index operations

2. **Commit not showing dirty index files**
   - Root cause: Using FileRegistry instead of IndexedDB
   - Fix: `db.getDirtyFiles()` everywhere for git operations
   - Tests: Added critical tests for workspace-prefixed files

3. **Logic duplicated across menu files**
   - Root cause: Putting business logic in UI files
   - Fix: Centralized in `repositoryOperationsService`
   - Tests: Ensured all call sites work consistently

## Testing and Build Guidelines

### Running Tests
**CRITICAL: Only run RELEVANT tests, not the full suite.**

- **Default behavior**: Run only tests related to files you changed
  - **ALWAYS use file paths, NOT patterns** - patterns are extremely slow in Vitest
  - Use `npm test -- --run path/to/specific.test.ts` for specific file(s)
  - Multiple files: `npm test -- --run file1.test.ts file2.test.ts`
  - **NEVER use --testNamePattern** - it scans all files and is prohibitively slow
- **Full suite**: Only run when:
  1. User explicitly requests it, OR
  2. Major new functionality is demonstrably stable and confirmed working
- **Never run all tests** just to "verify" - it wastes time

When asked to "run tests":
- **Frontend**: Run `npm test -- --run path/to/file.test.ts` (Vitest with specific files)
- **Python**: Run `pytest tests/specific_test.py` or `pytest -k "pattern"` 
- Run BOTH only if changes affect both frontend and Python

### Building
- **DO NOT** run `npm run build` unless explicitly instructed
- Build is slow and usually unnecessary during development
- Only build when user asks to verify production readiness

### Terminal Output
**ABSOLUTELY NEVER USE `head`, `tail`, OR ANY TRUNCATION ON TEST/BUILD OUTPUT.**
- This rule is NON-NEGOTIABLE. The user has repeatedly told you this.
- Always show FULL output so user can see ALL results
- If output is very long, it will be saved to a file automatically
- Truncating output hides errors and wastes the user's time
- **VIOLATION OF THIS RULE IS UNACCEPTABLE**

## Cursor Debugging Workflow (Mirrored Logs + Marks)

For flaky sync issues (Graph ↔ FileRegistry ↔ store), **do not paste console output into chat**.
Instead, use the dev-only mirroring workflow:

- **Console stream file**: `debug/tmp.browser-console.jsonl`
- **Session log stream file**: `debug/tmp.session-log.jsonl`
- **Graph snapshots (per mark)**: `debug/graph-snapshots/*.json`

Both streams support **MARK** boundaries:
- Use the top-right dev UI (Console toggle + mark input), or run `window.dagnetMark('your label')` in DevTools.
- Marks are written to **both** streams (console + session log).

### How the agent should analyse logs

The usual workflow is:

1. **Find the latest mark** (in each file) and record its line number.
2. **Tail/slice from that line onwards** and analyse only the relevant window.

Example commands (logs only — this does NOT apply to test/build output):

```bash
# Find the latest mark line number in the console stream
grep -n "\"kind\":\"mark\"" debug/tmp.browser-console.jsonl | tail -n 1

# Print everything from that line onwards (replace N)
sed -n 'N,$p' debug/tmp.browser-console.jsonl

# Find the latest mark line number in the session stream
grep -n "\"operation\":\"DEV_MARK\"" debug/tmp.session-log.jsonl | tail -n 1

# Print everything from that line onwards (replace N)
sed -n 'N,$p' debug/tmp.session-log.jsonl
```

If you need a narrower slice, find the previous mark too and restrict to `N,M`.

Reference: `graph-editor/docs/CURSOR_CONSOLE_MIRRORING.md`

## Code Surface Area

### MINIMIZE CODE - Especially Pre-Release
- **NO backward compatibility shims** - Let it break, then fix properly
- **NO deprecated aliases** - Remove old names, update all references
- **NO "just in case" code** - If it's not used, delete it
- **NO legacy wrappers** - Migrate callers to new APIs directly

### When Renaming/Refactoring
1. Make the change cleanly
2. Find all broken references
3. Fix them directly
4. Delete old code entirely

**WRONG:**
```typescript
// Legacy alias (deprecated)
export type OldName = NewName;
```

**RIGHT:**
```typescript
// Just use NewName everywhere, delete OldName entirely
export interface NewName { ... }
```

## Documentation Standards

### Implementation Plans
**CRITICAL**: Implementation plans are PROSE ONLY.

- ❌ **NEVER** include code snippets, code examples, or pseudo-code in implementation plans
- ❌ **NEVER** include test code, mock setups, or assertions in implementation plans
- ✅ **DO** describe WHAT to test in plain English
- ✅ **DO** list test scenarios as bullet points without code
- ✅ **DO** reference design document sections by name/number

Implementation plans should contain:
- File paths and what changes are needed (described in words)
- Test file paths and what scenarios to cover (described in words)
- Cross-references to design documents
- Dependencies between implementation phases

Implementation plans should NOT contain:
- TypeScript/JavaScript code blocks
- Test assertions or expect() statements
- Mock setups or fixture definitions
- Function signatures or interfaces
- Any code syntax whatsoever

## Remember

> "Menus are access points. Services are logic. Tests are proof."

If you're writing business logic in a menu file, STOP and move it to a service.
If you're duplicating code, STOP and centralize it.
If you're changing functionality, UPDATE THE TESTS.
Check architectural docs BEFORE making system changes.
**Reduce code surface area** - delete unused code, don't add compatibility shims.

